<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BlockBoard</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        :root {
            --bg-color: #222222;       
            --grid-gap-color: #444444; 
            --cell-black: #070707;     
            --cell-white: #eeeeee;     
            --text-color: #ffffff;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: "Press Start 2P", 'Segoe UI', sans-serif;
            color: var(--text-color);
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }

        body.grabbing {
            cursor: grabbing;
        }

        /* --- 毛玻璃 UI 组件 --- */
        .glass-panel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 12px 24px;
            background: rgba(30, 30, 30, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .header-ui {
            top: 20px;
        }

        .footer-ui {
            bottom: 20px;
            font-size: 0.6rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: #aaa;
        }

        h1 { 
            margin: 0;
            font-size: 1rem;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .footer-ui a {
            color: #fff;
            text-decoration: none;
            border-bottom: 1px dotted #666;
        }

        /* --- 视口与网格 --- */
        #viewport {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            will-change: transform;
        }

        #grid-container {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        #grid {
            display: grid;
            gap: 1px;
            background: var(--grid-gap-color); 
            padding: 1px;
        }

        .cell {
            background-color: var(--cell-black);
            cursor: pointer;
            position: relative;
        }

        @media (hover: hover) {
            .cell:hover {
                opacity: 0.8;
                z-index: 10;
                transform: scale(1.1);
                box-shadow: 0 0 8px rgba(0,0,0,0.8);
                transition: transform 0.2s;
            }
        }

        .cell.white {
            background-color: var(--cell-white);
            transform: rotateY(180deg);
            transition: transform 0.5s;
        }

        .cell.pending::after {
            content: "";
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.1);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

    <div class="glass-panel header-ui">
        <h1>BlockBoard</h1>
    </div>

    <div class="glass-panel footer-ui">
        <div>Online User: <span id="onlineCount" style="color: #4cd137;">...</span></div>
        <div>Made with ❤️ by <a href="https://motues.top" target="_blank">Motues</a></div>
    </div>

    <div id="viewport">
        <div id="grid-container">
            <div id="grid"></div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const grid = document.getElementById('grid');
        const gridContainer = document.getElementById('grid-container');
        
        let cells = []; 
        let pendingRequests = new Set(); 
        
        let gridMetrics = {
            width: 0,
            height: 0,
            cols: 0,
            rows: 0,
            cellSize: 0
        };

        let viewState = {
            panning: false,
            startX: 0,
            startY: 0,
            translateX: 0,
            translateY: 0,
            hasMoved: false
        };

        // --- Socket ---
        socket.on('init-game', (data) => {
            const { config, state } = data;
            initGrid(config, state);
        });

        socket.on('update-square', ({ index, isBlack }) => {
            pendingRequests.delete(index);
            if (cells[index]) {
                updateCellView(cells[index], isBlack);
                cells[index].classList.remove('pending');
            }
        });

        socket.on('online-users', (count) => {
            document.getElementById('onlineCount').textContent = count;
        });

        // --- 初始化 ---
        function initGrid(config, state) {
            grid.innerHTML = '';
            cells = [];

            gridMetrics.cols = config.cols;
            gridMetrics.rows = config.rows;
            gridMetrics.cellSize = config.cellSize;

            // 计算包含 gap 的总尺寸 (gap 1px)
            // 宽度 = (列数 * 格子宽) + ((列数-1) * 1px gap) + 2px border padding
            // 为了简化计算和视觉统一，我们近似为 cols * size 即可，误差很小
            gridMetrics.width = config.cols * config.cellSize;
            gridMetrics.height = config.rows * config.cellSize;

            grid.style.gridTemplateColumns = `repeat(${config.cols}, ${config.cellSize}px)`;
            grid.style.gridTemplateRows = `repeat(${config.rows}, ${config.cellSize}px)`;

            const totalSquares = config.rows * config.cols;
            for (let i = 0; i < totalSquares; i++) {
                const div = document.createElement('div');
                div.className = 'cell';
                div.style.width = `${config.cellSize}px`;
                div.style.height = `${config.cellSize}px`;

                updateCellView(div, state[i]);
                div.addEventListener('click', (e) => handleCellClick(e, i));
                grid.appendChild(div);
                cells.push(div);
            }
            centerGrid();
        }

        function updateCellView(el, isBlack) {
            if (isBlack) {
                el.classList.remove('white');
            } else {
                el.classList.add('white');
            }
        }

        function handleCellClick(e, index) {
            if (viewState.hasMoved) return; 
            if (!pendingRequests.has(index)) {
                pendingRequests.add(index);
                cells[index].classList.add('pending');
                socket.emit('toggle-square', index);
            }
        }

        function centerGrid() {
            viewState.translateX = 0;
            viewState.translateY = 0;
            updateTransform();
        }

        function updateTransform() {
            gridContainer.style.transform = `translate(${viewState.translateX}px, ${viewState.translateY}px)`;
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // --- 核心修改：严格的边界计算 ---
        function calculateBoundaries() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            
            // 逻辑：
            // 如果 Grid 宽 2000，屏幕 宽 1000。
            // 居中时，Grid左右各超出屏幕 500。
            // 我们向左拖，最多拖 500 (limitX)，这样 Grid 右边缘正好撞上屏幕右边缘。
            
            // 如果 Grid 比屏幕小，结果为 0 或 负数，Math.max(0, ...) 确保它为 0，即锁死居中。
            const limitX = Math.max(0, (gridMetrics.width - viewportW) / 2);
            const limitY = Math.max(0, (gridMetrics.height - viewportH) / 2);

            return {
                minX: -limitX,
                maxX: limitX,
                minY: -limitY,
                maxY: limitY
            };
        }

        function onPointerDown(e) {
            if (e.type === 'mousedown' && e.button !== 0) return;
            
            viewState.panning = true;
            viewState.hasMoved = false;
            
            const point = getPoint(e);
            viewState.startX = point.x - viewState.translateX;
            viewState.startY = point.y - viewState.translateY;
            
            viewState.clickStartX = point.x;
            viewState.clickStartY = point.y;
            
            document.body.classList.add('grabbing');
        }

        function onPointerMove(e) {
            if (!viewState.panning) return;
            e.preventDefault();

            const point = getPoint(e);
            let nextX = point.x - viewState.startX;
            let nextY = point.y - viewState.startY;

            // 实时获取边界并应用
            if (gridMetrics.width > 0) {
                const bounds = calculateBoundaries();
                nextX = clamp(nextX, bounds.minX, bounds.maxX);
                nextY = clamp(nextY, bounds.minY, bounds.maxY);
            }

            viewState.translateX = nextX;
            viewState.translateY = nextY;

            // 移动阈值判断
            if (Math.abs(point.x - viewState.clickStartX) > 5 || 
                Math.abs(point.y - viewState.clickStartY) > 5) {
                viewState.hasMoved = true;
            }

            requestAnimationFrame(updateTransform);
        }

        function onPointerUp() {
            viewState.panning = false;
            document.body.classList.remove('grabbing');
        }

        function getPoint(e) {
            if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        const container = document.body;
        container.addEventListener('mousedown', onPointerDown);
        container.addEventListener('touchstart', onPointerDown, { passive: false });
        container.addEventListener('mousemove', onPointerMove);
        container.addEventListener('touchmove', onPointerMove, { passive: false });
        container.addEventListener('mouseup', onPointerUp);
        container.addEventListener('touchend', onPointerUp);
        container.addEventListener('mouseleave', onPointerUp);

        // 窗口大小变化时，重新校验位置，防止留在无效区域
        window.addEventListener('resize', () => {
            const bounds = calculateBoundaries();
            viewState.translateX = clamp(viewState.translateX, bounds.minX, bounds.maxX);
            viewState.translateY = clamp(viewState.translateY, bounds.minY, bounds.maxY);
            updateTransform();
        });

    </script>
</body>
</html>